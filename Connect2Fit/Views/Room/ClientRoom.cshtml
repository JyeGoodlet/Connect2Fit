@using Microsoft.AspNet.Identity
@using Connect2Fit.Models;
@using System.Configuration;
@model ScheduleItem
@{
    ViewBag.Title = "Client Room";
}
<link href="~/Content/css/tracker.css" rel="stylesheet" />
<div ng-app="Room" class="ng-cloak" ng-controller="roomfunctions">
    <div ng-controller="webRTCVideo">
        <div class="row">
            <div class="col-md-4" id="intructorVideos">
                <h3>Instructor Feed</h3>
                <video style="display:none" autoplay="autoplay" id="callerVideo"></video>

                <video id="box0" style="display:none"></video>
                <video id="box1" style="display:none"></video>
                <video id="box2" style="display:none"></video>
                <video id="box3" style="display:none"></video>
                <video id="box4" style="display:none"></video>
                <div id="InstructorPlaceHolder" style="width: 320px;height: 240px; background: #337AB7;font-size:12em;color:#F3F3F4; text-align: center;"><i class="fa fa-video-camera "></i></div>

                <div style="margin-top:10px  ">
                    <span> Instructor </span>
                    <span ng-if="(instructor | InstructorConnected:connectedClients) == true" class="label label-success">Online</span>
                    <span ng-if="(instructor | InstructorConnected:connectedClients) == false" class="label label-danger">Offline</span>

                </div>
            </div>
            <div id="" class="col-md-7 .col-md-offset-1">
                
                
                <div ng-app="Tracking" ng-controller="TrackingPoints" id="TrackingPoints" class="row">
                    <div class="col-sm-8">
        
                       
                        <h3>Image frame</h3>
                        <div id="camera-error" class="alert alert-warning alert-dismissible fade in" role="alert">
                            <button type="button" class="close" data-dismiss="alert" aria-label="Close"><span aria-hidden="true">×</span></button>
                            <strong>Warning</strong> using fallback Video.
                        </div>
                        <video class="" id="source-video" width="{{cameraX}}" height="{{cameraY}}" preload autoplay loop muted controls></video>
                        <!-- canvas will be overlaid onto webcam -->
                        <canvas class="tracking-overlay" id="canvas" width="{{cameraX}}" height="{{cameraY}}"></canvas>

                    </div>
                    <div class="col-sm-4">
                        <h3>Avatar</h3>
                        <div id="avatarDiv" style="width:400px; height:500px;"></div>
                    </div>
                </div>
            </div>
        </div>
        <div id="connectedUsers">
            <h4>Connected Users</h4>
            <div ng-repeat="(key, value) in connectedClients">{{value}}</div>
        </div>
        <div ng-controller="Chat">
            <h2>Client Classes</h2>
            <table class="table table-striped">
                <thead>
                    <tr>
                        <th>Person</th>
                        <th>Message</th>

                    </tr>
                </thead>
                <tbody>
                    <tr class="animation" ng-repeat="message in messages">
                        <td>{{message.person}}</td>
                        <td>{{message.text}}</td>

                    </tr>
                </tbody>

            </table>
            <form>
                <input type="text" ng-model="newMessage" />
                <input type="submit" ng-click="addMessage()" value="Save" />
            </form>


        </div>
    </div>
</div>


@section scripts {
    <script src='~/Scripts/angular.js'></script>
    <script src="~/Content/Research/assets/tracking.js"></script>
<script src="~/Content/Research/assets/Avatar.js"></script>
    <script src="~/Scripts/jquery.signalR-2.2.0.js"></script>
    <script src="~/signalr/hubs"></script>
    <link rel="stylesheet" type="text/css" href="~/Content/easyrtc/easyrtc.css" />

    <!-- Assumes global locations for socket.io.js and easyrtc.js -->
    <script src="@ConfigurationManager.ConnectionStrings["easyrtc"].ConnectionString/socket.io/socket.io.js"></script>
    <script type="text/javascript" src="@ConfigurationManager.ConnectionStrings["easyrtc"].ConnectionString/easyrtc/easyrtc.js"></script>

    <script type="text/javascript">


        //start signalr connection
        //used to send and recieve data via server
        chat = $.connection.roomHub;
        $.connection.hub.start(
            function () {
                chat.server.joinRoom(@Model.id);
            }).done(function () {
                //closing stuff here
                //chat.server.leaveRoom(@Model.id);
            });



        //this is the module that all the angular controllers on this page use
        var app = angular.module('Room', []);




        //The Chat Controller allows the client to send and recieve text messages. Uses signalr
        app.controller('Chat', function ($scope, $http, $timeout) {
            //group id so messages are only sent to users in the same group. This is the room id
            var groupId = @Model.id;
            //users id
            $scope.userId = "@User.Identity.Name";



            //hold a list of all the classes
            $scope.messages = [];

            $scope.addMessage = function () {
                //add message
                var newMessage = { person: $scope.userId, text: $scope.newMessage }
                $scope.messages.push(newMessage);
                chat.server.message(groupId, newMessage);
                $scope.newMessage = "";
            }

            //onload
            var init = function() {
                //DO STUFF HERE

            }();

            //signalr functions
            chat.client.message = function (message) {

                //console.log(message);
                $scope.messages.push(message);
                $scope.$apply();

            }



        });


        //the webrtc controller handles the recieving of video from the instructor and also sends the clients audio to the instructor
        //webrtc is peer to peer so video does not pass through server.
        app.controller('webRTCVideo', function ($scope, $http) {
            var maxCALLERS = 5;
            $scope.instructor = "@Model.instructor.Email";
            $scope.instructorId = "";
            $scope.connectedClients = {};

            $(document).ready(function() {
                connect();

            })

            var selfEasyrtcid = "";


            function connect() {
                easyrtc.setSocketUrl("http://ec2-52-64-224-50.ap-southeast-2.compute.amazonaws.com:8080");

                easyrtc.enableAudio(true);
                easyrtc.enableVideo(false);
                easyrtc.dontAddCloseButtons();
                easyrtc.enableDataChannels(false);
                easyrtc.setUsername("@User.Identity.Name");
                easyrtc.joinRoom("@Model.id", null, loginSuccess, loginFailure)


                easyrtc.setRoomOccupantListener(callEverybodyElse);

                easyrtc.easyApp("easyrtc.audioVideoSimple", "callerVideo", ["box0", "box1", "box2", "box3", "box4"], loginSuccess, loginFailure);

                easyrtc.setOnCall( function(easyrtcid, slot) {
                    //kick duplicate users.
                    if ( easyrtc.idToName(easyrtcid) == "@User.Identity.Name") {
                        //TODO: go to an error page
                        window.location.replace("/Scheduler/MyClasses?roomKick=true");

                    }


                    var user = easyrtc.idToName(easyrtcid);




                    if (user == "@Model.instructor.Email") {
                        console.log("instructor");
                        $("#box" + slot).show();
                        $("#InstructorPlaceHolder").hide();
                        $scope.instructorId = easyrtcid;
                    }
                    else {
                        console.log("not instructor");
                    }
                    $scope.connectedClients[easyrtcid] = easyrtc.idToName(easyrtcid);
                    $scope.$apply();

                });

                easyrtc.setOnHangup(function(easyrtcid, slot) {

                    //check if instructor has left room
                    if ($scope.instructorId == easyrtcid) {
                        $("#box" + slot).hide();
                        $("#InstructorPlaceHolder").show();
                    }

                    //remove client from list
                    delete $scope.connectedClients[easyrtcid];

                    $scope.$apply();


                });
            }



            function callEverybodyElse(roomName, otherPeople) {




                easyrtc.setRoomOccupantListener(null); // so we're only called once.

                var list = [];
                var connectCount = 0;
                for(var easyrtcid in otherPeople ) {
                    list.push(easyrtcid);
                    $scope.$apply();
                }
                //
                // Connect in reverse order. Latter arriving people are more likely to have
                // empty slots.
                //
                function establishConnection(position) {
                    function callSuccess() {
                        connectCount++;
                        if( connectCount < maxCALLERS && position > 0) {
                            establishConnection(position-1);
                        }
                    }
                    function callFailure(errorCode, errorText) {
                        easyrtc.showError(errorCode, errorText);
                        if( connectCount < maxCALLERS && position > 0) {
                            establishConnection(position-1);
                        }
                    }
                    easyrtc.call(list[position], callSuccess, callFailure);

                }
                if( list.length > 0) {
                    establishConnection(list.length-1);
                }
            }



            function loginSuccess(easyrtcid) {
                selfEasyrtcid = easyrtcid;
                document.getElementById("status").innerHTML = "Connected";
            }


            function loginFailure(errorCode, message) {
                console.log(message);
                easyrtc.showError(errorCode, message);
            }
        })

        //this controller controllers room general functions, eg end class.
        app.controller('roomfunctions', function ($scope, $http, $timeout, $interval) {

            //end class notification
            chat.client.endClassNotify = function() {


                //show notification
                $.notify("Class has ended Room will close in 5 minutes", { globalPosition: 'top center',  className: "error"  });

            }


            //end class 1 hour after class start. This is to prevent anyone just setting in a room forever
            var classEndTimeout = function() {

                //create time object
                classDateTime = moment("@Model.ClassDateTime", "DD-MM-YYYY HH:mm A");

                //check if an hour has passed every 5 minutes
                endNotification = false;
                $interval(function() {
                    
                    
                    //if class has ended kick user
                    if (classDateTime.clone().add(1,'h').isBefore(moment()) ) {
                        $.notify("Room Closing", { globalPosition: 'top center',  className: "error", autoHideDelay: 10000,  });
                        $timeout(function() {
                            window.location.replace("/Scheduler/MyClasses");
                        }, 2000);
                    }

                    //if 5 minutes to class end send notification
                    if (classDateTime.clone().add(55,'m').isBefore(moment()) && endNotification == false) {
                        $.notify("Class has ended Room will close in 5 minutes", { globalPosition: 'top center',  className: "error"  });
                        endNotification = true;
                    }

                    

                }, 1000 * 60  );
                
                    
            }()


            //end class
            chat.client.endClass = function() {
                $.notify("Room Closing", { globalPosition: 'top center',  className: "error", autoHideDelay: 10000,  });

                $timeout(function() {
                    window.location.replace("/Scheduler/MyClasses");
                }, 2000);

            }




        });

        //load avatar data
        var avatar = new avatar('avatarDiv');
        avatar.setInitialPoints();

        //The trackingpoints controllers sends the clients tracking points to the instructor via signalr
        app.controller('TrackingPoints', function ($scope, $http) {
            


            var trackingPoint = function (name, startX, startY) {
                this.name = name;
                this.x = startX;
                this.y = startY;
            };

            $scope.time = new Date();
            $scope.character = {};
            // set viewport res
            $scope.cameraX = 640;
            $scope.cameraY = 480;
            $scope.updatePoint = function (oldPoint, newPoint) {
                $scope.character[newPoint.name] = newPoint;
                //console.log($scope.character['R Shoulder']);
                $scope.$apply();
                return false;
            };
            $scope.scaleX = function (x) {
                return Math.round($scope.cameraX * x);
            };
            $scope.scaleY = function (y) {
                return Math.round($scope.cameraY * y);
            };
            $scope.paintPoints = function (context) {
                context.font = '24px Helvetica';
                context.fillStyle = "#fff";
                var points = $scope.character;
                for (x in points) {
                    var point = points[x];
                    context.fillText('+', point.x - 6, point.y + 6);
                };
                //send points to server
                sendPointsServer();

                return false;
            };

            //send points to server/instructor. With ms throttle
            var sendPointsServer = function() {
                var throttle = 35;
                $.connection.hub.start().done(function () {

                    diffTime = new Date() - $scope.time;

                    if (diffTime > throttle) {
                        chat.server.sendpoint(@Model.id, vm.character);
                        //console.log(diffTime);
                        $scope.time = new Date();
                    }


                });

            }

            //on start
            var init = function () {



                $('#camera-error').hide();
                var x = $scope.scaleX;
                var y = $scope.scaleY;
                $scope.character['L Hand'] = new trackingPoint('L Hand', x(0.28), y(0.05));
                $scope.character['L Elbow'] = new trackingPoint('L Elbow', x(0.28), y(0.27));
                $scope.character['L Shoulder'] = new trackingPoint('L Shoulder', x(0.41), y(0.24));
                $scope.character['R Shoulder'] = new trackingPoint('R Shoulder', x(0.59), y(0.24));
                $scope.character['R Elbow'] = new trackingPoint('R Elbow', x(0.65), y(0.37));
                $scope.character['R Hand'] = new trackingPoint('R Hand', x(0.68), y(0.1));
                $scope.character['Head'] = new trackingPoint('Head', x(0.5), y(0.15));
                $scope.character['Body'] = new trackingPoint('Body', x(0.5), y(0.37));
                $scope.character['L Hip'] = new trackingPoint('L Hip', x(0.42), y(0.6));
                $scope.character['R Hip'] = new trackingPoint('R Hip', x(0.54), y(0.6));
                $scope.character['L Knee'] = new trackingPoint('L Knee', x(0.39), y(0.75));
                $scope.character['R Knee'] = new trackingPoint('R Knee', x(0.57), y(0.75));
                $scope.character['L Foot'] = new trackingPoint('L Foot', x(0.38), y(0.98));
                $scope.character['R Foot'] = new trackingPoint('R Foot', x(0.58), y(0.98));
                vm = $scope;


                avatar.paintAvatar();


                // tracker setup
                var trackYellow = new tracking.ColorTracker(['yellow']);
                // config tracker
                trackYellow.setMinDimension(2);
                trackYellow.setMinGroupSize(1);
                trackYellow.on('track', function (event) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (event.data.length === 0) {
                        // No colors were detected in this frame.
                    } else {
                        event.data.forEach(function (rect) {
                            // only for testing purposes
                            context.strokeStyle = rect.color;
                            context.strokeRect(rect.x, rect.y, rect.width, rect.height);
                            // different colours for each joint will be added to remove crossover
                            var newX, newY;
                            var trackingRange = 18;
                            for (trackedPoint in vm.character) {
                                //console.log(vm.character[trackedPoint]);
                                trackedPoint = vm.character[trackedPoint];
                                if ((trackedPoint.x > (rect.x - trackingRange) &&
                                    trackedPoint.x < (rect.x + rect.width + trackingRange)) &&
                                    (trackedPoint.y > (rect.y - trackingRange) &&
                                    trackedPoint.y < (rect.y + rect.height + trackingRange))) {
                                    newX = rect.x + (rect.width / 2);
                                    newY = rect.y + (rect.height / 2);
                                    vm.updatePoint(trackedPoint, new trackingPoint(trackedPoint.name, newX, newY));

                                }
                            };
                            avatar.update(vm.character);
                        });
                    }
                    vm.paintPoints(context);
                });
                // start the colour tracker
                var canvas = $("#canvas")[0];
                var context = canvas.getContext('2d');
                // reference to view model function
                vm.paintPoints(context);
                // error handler
                function windowError(message) {
                    div = $('#camera-error');
                    div.append(message);
                    div.show();
                    var source = document.createElement('source');
                    source.src = "@Url.Content("~/Content/img/Fallback.m4v")";
                    source.type = "video/mp4";
                    $('#source-video').append(source);
                    source = document.createElement('source');
                    source.src = "@Url.Content("~/Content/img/Fallback.ogv")";
                    source.type = "video/ogg";
                    $('#source-video').append(source);
                }
                window.onerror = windowError;
                var trackingTask = tracking.track('#source-video', trackYellow, { camera: true });
            }()


        });


        //this filter is used to show if the instructor is offline or online
        angular.module('Room').filter('InstructorConnected', function() {
            return function(user, onlineUsers) {

                for (var i in onlineUsers) {

                    if (onlineUsers[i] == user) {

                        return true;
                    }
                }
                return false;

            };
        });


    </script>

}